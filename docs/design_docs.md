overview
===

I wanted a store that i could use for test practise.
The idea is to have something extremely dumb, 
with helper functions.

I went for a dumb js object with helper functions, 
over a class,
because i felt helper functions were more obvious.

The library is supposed to be simple,
supposed to be useless,
so that i can easily extend it later,
for coding and testing practise.

The less the code does here, 
The more i have to do later.
Which is fantastic for a practise tool.

exports:
===

* A function to create the store
* * A frozen object containing the availabe types for the store
* A function to generate values for the object
* * A frozen object that contains the uniqueness of the values in the store
* A function that checks if the store has been changed
* A function that creates a "cleaned" version of the store, given to it.


code structure:
===

## A frozen object containing the availabe types for the store

### Entries:
* keys      : ( string ) type
* values    : ( string ) type

------------------------------------------------------------------------------------

## A frozen object that contains the uniqueness of the values in the store

### Entries Description:
* keys      : ( string ) name of the type
* values    : ( boolean ) whether or not the type needs to be unique

------------------------------------------------------------------------------------

## A function to create the store

### Signature
( valuesType="string", valuesCount=10 ) => {};

### Overview
The function is to:
* Create a store object
* Initialise it's structure
* Create it's values

### Aspects
* pure?     : true
* async?    : false
* exceptions? :
* * "typeError" => user has given an invalid type to the function

### Parameters:
* valuesType    => ( string ) The type from the frozen object containing available types.
* valuesCount   => ( integer ) The number of entries in the values array.


### Return value:
    store : {
        types : typeof( values_in_array ),
        hasBeenChanged : bool,
        initialValueCount : int,
        values : [
            ... an array of values, of type this.types ...
        ]
    }

### Tests
* It returns an object with the keys : [ "types", "hasBeenChanged", "initialValueCount", "values" ]

* 'types' property matches the given type

* "values" property is an array of values, with the type of type given

* "hasBeenChanged" property defaults to false

* "values" property is the length of the count given

* "values" property has the following uniqueness for the following types:
* * string  => unique,
* * int     => unique,
* * bool    => all are the same
* * object  => all arrays are unique, with a single unique value in them

* The function throws an exception if given an unrecognised type

------------------------------------------------------------------------------------

## A function to generate values for the object

### Signature
    ( type, count ) => [ ... values ... ]

### Overview
Generate an array of values, according to the type given, and the count.
The values should adhere to the uniqueness object.

### Aspects
* pure?     : true
* async?    : false
* exceptions? :
* * "typeError" => An unsupported error was given

### Parameters
* type => ( string ) One of our supported types
* count => ( int ) the number of entries in the array

### Return value
    [... values array ...]

### Tests
* Check that the array adheres to the uniqueness object
* Check that the expected number of items are in the array
* Check that the values are of the expected type

------------------------------------------------------------------------------------

## A function that checks if the store has been changed

### Signature
    ( store ) => bool

### Overview
Take a given store, check if it's been altered since it was created.

Returns true if it's changed, false otherwise.

### Aspects
* pure?     : true
* async?    : false
* exceptions? : none

### Parameters
* store => generated by the store generator function

### Return value
    boolean => Whether or not the types were altered.

### Tests
* test that it returns true when ANY of the following are met:
* * The store's type has been altered
* * The length of values doesn't match the initialCount
* * The values in the values array aren't the default values for the given type
* * hasBeenAltered is set to true
* test that it returns false when ALL the following are met:
* * The initialCount matches values length
* * The types in the array match the type in the object
* * hasBeenAltered is set to false

------------------------------------------------------------------------------------

## A function that creates a "cleaned" version of the store, given to it.

### Signature
    ( store ) => ( { ... cleaned store ... } )

### Overview
If a stores' "hasBeenChanged" values has been set to true,
it creates a new store, with reset values.
A "clean" store is one where:
* all of the values are reset to default
* hasBeenChanged is set to false
* the lenth of the values is set back to "initialCount"

### Aspects
* pure?     : true
* async?    : false
* exceptions? : none

### Parameters
* store => a store create from the create function

### Return value
if it had been changed:


    { ...cleaned store... }

otherwise:


    { ... copy of the store ... }

### Tests
* Returns an identical copy of the object if it's not been changed
* A store with more values than it's initial count has the values list reset
* A store where the type doesn't match the types in the array, is reset
* A store that has an invalid type has it's type set to that of the first value in the array
* Has been changed is reset to false